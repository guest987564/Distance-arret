# app.py ‚Äî Simulateur de distance d‚Äôarr√™t
import streamlit as st
import numpy as np
import scipy.stats as stats
import math
import time
import plotly.graph_objects as go
import plotly.express as px
from typing import Tuple
import textwrap

st.set_page_config(page_title="Simulateur ‚Äì Distance d‚Äôarr√™t",
                   page_icon="üöó", layout="wide")
st.title("Simulateur de distance d'arr√™t")
G = 9.81  # gravit√© (m¬∑s-2)

# ==============================================================
# 1. Lois de probabilit√©
# ==============================================================

# ---- Vitesse r√©elle (triangulaire, compteur sur-estimant) ----
def speed_params(v_disp: float) -> Tuple[float, float, float]:
    Œî = min(4 + 0.05 * v_disp, 8)           # tol√©rance UN-R39
    return v_disp - Œî, v_disp - Œî/2, v_disp

def sample_speed(v_disp: float, n: int, rng=None) -> np.ndarray:
    rng = rng or np.random
    a, c, b = speed_params(v_disp)
    return rng.triangular(a, c, b, n)

def speed_pdf(x, v_disp):
    a, c, b = speed_params(v_disp)
    return np.where(
        (x >= a) & (x <= b),
        np.where(x < c,
                 2*(x-a)/((b-a)*(c-a)),
                 2*(b-x)/((b-a)*(b-c))),
        0)

# ---- Temps de r√©action (Weibull tronqu√©) ----
PROFILE_MED = {
    "Alerte": 0.9,
    "Standard": 1.5,
    "Fatigu√©": 2.0,
    "Senior": 2.0,
}
K_WEIB = 2.2

def weib_scale(med):               # Œª pour m√©diane donn√©e
    return med / (math.log(2)**(1/K_WEIB))

def sample_tr(profile, n, rng=None):
    lam = weib_scale(PROFILE_MED[profile])
    return np.clip(
        stats.weibull_min.rvs(K_WEIB, scale=lam, size=n, random_state=rng),
        0.3,
        3,
    )

def tr_pdf(x, profile):
    lam = weib_scale(PROFILE_MED[profile])
    pdf = stats.weibull_min.pdf(x, K_WEIB, scale=lam)
    pdf[(x < .3) | (x > 3)] = 0
    return pdf

# ---- Adh√©rence Œº (B√™ta born√©e) ----
SURFACE_Œº = {
    "sec":     {"neuf": .85, "mi-usure": .80, "us√©": .75},
    "mouille": {"neuf": .55, "mi-usure": .47, "us√©": .40},
    "neige":   {"neuf": .25, "mi-usure": .25, "us√©": .25},
    "glace":   {"neuf": .10, "mi-usure": .10, "us√©": .10},
}
A_B, B_B = 2, 3

def base_mu(surface, tyre):
    Œº = SURFACE_Œº[surface][tyre]
    return np.clip(Œº, .2, .9)

def mu_bounds(Œº):
    return max(.2, Œº-.15), min(.9, Œº+.15)

def sample_mu(surface, tyre, n, rng=None):
    Œº0 = base_mu(surface, tyre)
    Œº_min, Œº_max = mu_bounds(Œº0)
    rng = rng or np.random
    return Œº_min + (Œº_max - Œº_min) * rng.beta(A_B, B_B, size=n)

def mu_pdf(x, surface, tyre):
    Œº0 = base_mu(surface, tyre)
    Œº_min, Œº_max = mu_bounds(Œº0)
    pdf = stats.beta.pdf((x-Œº_min)/(Œº_max-Œº_min), A_B, B_B)/(Œº_max-Œº_min)
    pdf[(x < Œº_min) | (x > Œº_max)] = 0
    return pdf

# ---- Pente Œ∏ (normale tronqu√©e ¬±1¬∞ autour du centre) ----
SLOPE = {
    "Plat": 0,
    "Mont√©e 2¬∞": 2,
    "Mont√©e 4¬∞": 4,
    "Descente 2¬∞": -2,
    "Descente 4¬∞": -4,
}

def sample_theta(cat, n, rng=None):
    Œº = SLOPE[cat]
    a, b = (-1) / 0.5, 1 / 0.5
    return stats.truncnorm.rvs(a, b, loc=Œº, scale=0.5, size=n, random_state=rng)

def theta_pdf(x, cat):
    Œº = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    pdf = stats.truncnorm.pdf(x, a, b, loc=Œº, scale=.5)
    pdf[(x < Œº-1) | (x > Œº+1)] = 0
    return pdf

# ==============================================================
# 2. Mod√®le physique (distance d‚Äôarr√™t)
# ==============================================================

def stopping_distance(v_kmh, t_r, Œº, Œ∏_deg):
    v_ms = v_kmh / 3.6                        # conversion km/h ‚Üí m/s
    Œ∏ = np.radians(Œ∏_deg)
    denom = 2*G*(Œº*np.cos(Œ∏) + np.sin(Œ∏))
    with np.errstate(divide="ignore", invalid="ignore"):
        dist = v_ms * t_r + (v_ms**2) / denom   # r√©action + freinage
    dist[denom <= 0] = np.inf
    return dist

# ==============================================================
# 3. Monte-Carlo adaptatif
# ==============================================================

def run_mc(p, batch=50_000, max_iter=20, progress_callback=None):
    z = stats.norm.ppf(.5 + p["conf"]/2)       # z-score dynamique
    rel_tol = 1 - p["conf"]                    # crit√®re largeur/ moyenne
    dist = np.empty(0)

    for i in range(max_iter):
        v = sample_speed(p["speed"], batch)
        t = sample_tr(p["profile"], batch)
        Œº = sample_mu(p["surface"], p["tyre"], batch)
        Œ∏ = sample_theta(p["slope"], batch)

        ok = Œº*np.cos(np.radians(Œ∏)) + np.sin(np.radians(Œ∏)) > 0
        while not ok.all():                    # resampling invalid combos
            idx = np.where(~ok)[0]
            v[idx] = sample_speed(p["speed"], len(idx))
            t[idx] = sample_tr(p["profile"], len(idx))
            Œº[idx] = sample_mu(p["surface"], p["tyre"], len(idx))
            Œ∏[idx] = sample_theta(p["slope"], len(idx))
            ok = Œº*np.cos(np.radians(Œ∏)) + np.sin(np.radians(Œ∏)) > 0

        assert ok.all(), "Invalid combinaison donnant denom <= 0"

        dist = np.concatenate((dist, stopping_distance(v, t, Œº, Œ∏)))
        sem = np.std(dist, ddof=1)/np.sqrt(len(dist))
        if progress_callback:
            progress_callback(int((i + 1) / max_iter * 100))
        if z * sem / dist.mean() < rel_tol:
            break
    return dist

# ==============================================================
# 4. Interface Streamlit
# ==============================================================

st.sidebar.header("Param√®tres")
advanced = st.sidebar.toggle("Mode avanc√©")

if advanced:
    speed   = st.sidebar.slider("Vitesse compteur (km/h)", 30,130,90,5)
    profile = st.sidebar.radio("Profil conducteur", list(PROFILE_MED), 1)
    surface = st.sidebar.radio("Chauss√©e", list(SURFACE_Œº), 0)
    tyre    = st.sidebar.radio("Pneus", list(SURFACE_Œº["sec"].keys()), 0)
    slope   = st.sidebar.radio("Pente", list(SLOPE), 0)
    conf    = st.sidebar.slider("Confiance (%)", 0, 100, 95)/100
else:
    PRESETS = {
        "Ville (sec)":      {"speed": 30,  "profile": "Standard", "surface": "sec",     "tyre": "neuf",     "slope": "Plat"},
        "Route mouill√©e":   {"speed": 80,  "profile": "Fatigu√©",  "surface": "mouill√©", "tyre": "mi-usure", "slope": "Plat"},
        "Autoroute (sec)":  {"speed": 130, "profile": "Alerte",   "surface": "sec",     "tyre": "neuf",     "slope": "Plat"},
    }
    preset_name = st.sidebar.radio("Pr√©r√©glage", list(PRESETS))
    pr = PRESETS[preset_name]
    speed, profile, surface, tyre, slope = pr.values()
    conf = 0.95

child_d = st.sidebar.slider("Distance de l'enfant (m)",5.,100.,25.,.5)
run_sim = st.sidebar.button("Lancer la simulation")

params = {
    "speed": speed,
    "profile": profile,
    "surface": surface,
    "tyre": tyre,
    "slope": slope,
    "conf": conf,
}

tab_res, tab_graph, tab_var, tab_about = st.tabs([
    "üìä R√©sultats",
    "üìà Graphiques",
    "üîé Variables",
    "‚ÑπÔ∏è √Ä propos",
])

# --------------------------------------------------------------
# 5. Ex√©cution / affichage
# --------------------------------------------------------------
if "dist" not in st.session_state:
    st.session_state["dist"] = None
    st.session_state["params"] = None

if run_sim:
    t0 = time.time()
    progress = st.progress(0)
    with st.spinner("Simulation en cours..."):
        dist = run_mc(params, progress_callback=progress.progress)
    progress.empty()
    dt = time.time() - t0
    st.session_state["dist"] = dist
    st.session_state["params"] = params
elif (
    st.session_state["dist"] is not None
    and st.session_state["params"] == params
):
    dist = st.session_state["dist"]
    dt = 0
else:
    dist = None
if dist is not None:
    mean, p95 = dist.mean(), np.percentile(dist, 95)
    p_coll = (dist >= child_d).mean()

    # -------- KPIs --------------------------------------
    with tab_res:
        c1, c2, c3 = st.columns(3)
        c1.metric("Distance moyenne (m)", f"{mean:.1f}")
        c2.metric("Distance P95 (m)", f"{p95:.1f}")
        c3.metric("Collision", f"{p_coll*100:.1f} %")

    # -------- Graphiques --------------------------------------
    with tab_graph:
        fig_hist = (
            px.histogram(dist, nbins=60, labels={"value": "Distance d'arr√™t (m)"})
            .update_layout(title="Distribution simul√©e")
        )
        st.plotly_chart(fig_hist, use_container_width=True)

        sorted_dist = np.sort(dist)
        cdf = np.arange(1, len(sorted_dist) + 1) / len(sorted_dist)
        fig_cdf = go.Figure(go.Scatter(x=sorted_dist, y=cdf, name="CDF"))
        fig_cdf.add_vline(
            x=child_d,
            line_dash="dash",
            line_width=2,
            annotation_text="Position de l‚Äôenfant",
            annotation_position="top",
        )
        fig_cdf.update_layout(
            title="Probabilit√© de s'arr√™ter",
            xaxis_title="Distance d'arr√™t (m)",
            yaxis_title="Probabilit√©",
        )
        st.plotly_chart(fig_cdf, use_container_width=True)

        rng_scatter = np.random.default_rng(42)
        v_s = sample_speed(speed, 1000, rng_scatter)
        t_s = sample_tr(profile, 1000, rng_scatter)
        Œº_s = sample_mu(surface, tyre, 1000, rng_scatter)
        fig_scatter = px.scatter(
            x=t_s,
            y=v_s,
            color=Œº_s,
            color_continuous_scale="Blues",
            labels={"x": "Temps de r√©action (s)", "y": "Vitesse (km/h)", "color": "Adh√©rence"},
            title="Temps de r√©action vs Vitesse",
        )
        st.plotly_chart(fig_scatter, use_container_width=True)
        st.caption(
            f"{format(len(dist), ',').replace(',', '\u202f')} tirages ‚Äì {dt:.2f}s"
        )

    # -------- Distributions internes ----------------------------------
    with tab_var:
        st.subheader("Distributions internes")
        rng = np.random.default_rng(42)

        with st.expander("Vitesse r√©elle"):
            xs = np.linspace(speed_params(speed)[0], speed, 300)
            fig = go.Figure()
            data = sample_speed(speed, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=speed_pdf(xs, speed))
            fig.update_layout(title="Vitesse r√©elle (km/h)")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Temps de r√©action"):
            xs = np.linspace(0.3, 3, 300)
            fig = go.Figure()
            data = sample_tr(profile, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=tr_pdf(xs, profile))
            fig.update_layout(title="Temps de r√©action (s)")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Adh√©rence Œº"):
            Œº_min, Œº_max = mu_bounds(base_mu(surface, tyre))
            xs = np.linspace(Œº_min, Œº_max, 300)
            fig = go.Figure()
            data = sample_mu(surface, tyre, 10_000, rng)
            fig.add_histogram(
                x=data,
                nbinsx=40,
                histnorm="probability density",
                opacity=0.6,
            )
            fig.add_scatter(x=xs, y=mu_pdf(xs, surface, tyre))
            fig.update_layout(title="Coefficient d'adh√©rence Œº")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Pente Œ∏"):
            ŒºŒ∏ = SLOPE[slope]
            xs = np.linspace(ŒºŒ∏ - 1, ŒºŒ∏ + 1, 300)
            fig = go.Figure()
            data = sample_theta(slope, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=theta_pdf(xs, slope))
            fig.update_layout(title="Angle de pente Œ∏ (¬∞)")
            st.plotly_chart(fig, use_container_width=True)
else:
    tab_res.info("Aucun r√©sultat pour l'instant.")
    tab_var.markdown("_Les distributions appara√Ætront apr√®s simulation._")

# ------------------ √Ä propos ----------------------------------
with tab_about:
    mu_base = base_mu(surface, tyre)        # valeur nominale Œº
    tr_nom  = PROFILE_MED[profile]                 # m√©diane temps r√©action

    st.markdown("### Vos param√®tres actuels")
    st.markdown(
        textwrap.dedent(
            f"""
            ‚Ä¢ **Vitesse compteur :** {speed} km/h
            ‚Ä¢ **Profil conducteur :** {profile}  ‚Äì temps de r√©action m√©dian ‚âà {tr_nom:.1f} s
            ‚Ä¢ **Chauss√©e :** {surface}
            ‚Ä¢ **Pneus :** {tyre}
            ‚Ä¢ **Adh√©rence nominale Œº :** {mu_base:.2f} (plage simul√©e ¬±0,15)
            ‚Ä¢ **Pente :** {SLOPE[slope]:+} ¬∞ ({slope})
            ‚Ä¢ **Confiance MC :** {conf*100:.0f} %
            ‚Ä¢ **Distance enfant :** {child_d} m
            """
        )
    )
