# app.py â€” Simulateur de distance dâ€™arrÃªt
import streamlit as st
import numpy as np
import scipy.stats as stats
import math, time
import plotly.graph_objects as go
import plotly.express as px
from typing import Tuple

st.set_page_config(page_title="Simulateur â€“ Distance dâ€™arrÃªt",
                   page_icon="ðŸš—", layout="wide")
st.title("Simulateur de distance d'arrÃªt")
G = 9.81  # gravitÃ© (mÂ·s-2)

# ==============================================================
# 1. Lois de probabilitÃ©
# ==============================================================

# ---- Vitesse rÃ©elle (triangulaire, compteur sur-estimant) ----
def speed_params(v_disp: float) -> Tuple[float, float, float]:
    Î” = min(4 + 0.05 * v_disp, 8)           # tolÃ©rance UN-R39
    return v_disp - Î”, v_disp - Î”/2, v_disp

def sample_speed(v_disp: float, n: int) -> np.ndarray:
    a, c, b = speed_params(v_disp)
    return np.random.triangular(a, c, b, n)

def speed_pdf(x, v_disp):
    a, c, b = speed_params(v_disp)
    return np.where(
        (x >= a) & (x <= b),
        np.where(x < c,
                 2*(x-a)/((b-a)*(c-a)),
                 2*(b-x)/((b-a)*(b-c))),
        0)

# ---- Temps de rÃ©action (Weibull tronquÃ©) ----
PROFILE_MED = {
    "Alerte": 0.9,
    "Standard": 1.5,
    "FatiguÃ©": 2.0,
    "Senior": 2.0,
    "Lent": 2.5,
}
K_WEIB = 2.2

def weib_scale(med):               # Î» pour mÃ©diane donnÃ©e
    return med / (math.log(2)**(1/K_WEIB))

def sample_tr(profile, n):
    lam = weib_scale(PROFILE_MED[profile])
    return np.clip(stats.weibull_min.rvs(K_WEIB, scale=lam, size=n), .3, 3)

def tr_pdf(x, profile):
    lam = weib_scale(PROFILE_MED[profile])
    pdf = stats.weibull_min.pdf(x, K_WEIB, scale=lam)
    pdf[(x < .3) | (x > 3)] = 0
    return pdf

# ---- AdhÃ©rence Î¼ (BÃªta bornÃ©e) ----
SURFACE_Î¼ = {
    "sec":     {"neuf": .85, "use": .75},
    "mouille": {"neuf": .55, "use": .40},
    "neige":   {"neuf": .25, "use": .25},
    "glace":   {"neuf": .10, "use": .10},
}
A_B, B_B = 2, 3

def base_mu(surface, tyre, water):
    Î¼ = SURFACE_Î¼[surface][tyre]
    Î¼ -= .05 if water == "pluie"   else (.10 if water == "flaques" else 0)
    return np.clip(Î¼, .2, .9)

def mu_bounds(Î¼):
    return max(.2, Î¼-.15), min(.9, Î¼+.15)

def sample_mu(surface, tyre, water, n):
    Î¼0 = base_mu(surface, tyre, water)
    Î¼_min, Î¼_max = mu_bounds(Î¼0)
    return Î¼_min + (Î¼_max-Î¼_min)*stats.beta.rvs(A_B, B_B, size=n)

def mu_pdf(x, surface, tyre, water):
    Î¼0 = base_mu(surface, tyre, water)
    Î¼_min, Î¼_max = mu_bounds(Î¼0)
    pdf = stats.beta.pdf((x-Î¼_min)/(Î¼_max-Î¼_min), A_B, B_B)/(Î¼_max-Î¼_min)
    pdf[(x < Î¼_min) | (x > Î¼_max)] = 0
    return pdf

# ---- Pente Î¸ (normale tronquÃ©e Â±1Â° autour du centre) ----
SLOPE = {
    "Plat": 0,
    "MontÃ©e 2Â°": 2,
    "MontÃ©e 4Â°": 4,
    "MontÃ©e 6Â°": 6,
    "Descente 2Â°": -2,
    "Descente 4Â°": -4,
}

def sample_theta(cat, n):
    Î¼ = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    return stats.truncnorm.rvs(a, b, loc=Î¼, scale=.5, size=n)

def theta_pdf(x, cat):
    Î¼ = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    pdf = stats.truncnorm.pdf(x, a, b, loc=Î¼, scale=.5)
    pdf[(x < Î¼-1) | (x > Î¼+1)] = 0
    return pdf

# ==============================================================
# 2. ModÃ¨le physique (distance dâ€™arrÃªt)
# ==============================================================

def stopping_distance(v_kmh, t_r, Î¼, Î¸_deg):
    v_ms = v_kmh / 3.6                        # conversion km/h â†’ m/s
    Î¸ = np.radians(Î¸_deg)
    denom = 2*G*(Î¼*np.cos(Î¸) + np.sin(Î¸))
    with np.errstate(divide="ignore", invalid="ignore"):
        dist = v_ms * t_r + (v_ms**2) / denom   # rÃ©action + freinage
    dist[denom <= 0] = np.inf
    return dist

# ==============================================================
# 3. Monte-Carlo adaptatif
# ==============================================================

def run_mc(p, batch=50_000, max_iter=10, progress_callback=None):
    z = stats.norm.ppf(.5 + p["conf"]/2)       # z-score dynamique
    rel_tol = 1 - p["conf"]                    # critÃ¨re largeur/ moyenne
    dist = np.empty(0)

    for i in range(max_iter):
        v = sample_speed(p["speed"], batch)
        t = sample_tr(p["profile"], batch)
        Î¼ = sample_mu(p["surface"], p["tyre"], p["water"], batch)
        Î¸ = sample_theta(p["slope"], batch)

        ok = Î¼*np.cos(np.radians(Î¸)) + np.sin(np.radians(Î¸)) > 0
        while not ok.all():                    # resampling invalid combos
            idx = np.where(~ok)[0]
            v[idx] = sample_speed(p["speed"], len(idx))
            t[idx] = sample_tr(p["profile"], len(idx))
            Î¼[idx] = sample_mu(p["surface"], p["tyre"], p["water"], len(idx))
            Î¸[idx] = sample_theta(p["slope"], len(idx))
            ok = Î¼*np.cos(np.radians(Î¸)) + np.sin(np.radians(Î¸)) > 0

        dist = np.concatenate((dist, stopping_distance(v, t, Î¼, Î¸)))
        sem = np.std(dist, ddof=1)/np.sqrt(len(dist))
        if progress_callback:
            progress_callback((i+1)/max_iter)
        if z * sem / dist.mean() < rel_tol:
            break
    return dist

# ==============================================================
# 4. Interface Streamlit
# ==============================================================

st.sidebar.header("ParamÃ¨tres")

speed   = st.sidebar.slider("Vitesse compteur (km/h)", 30,130,90,5)
profile = st.sidebar.selectbox("Profil conducteur", list(PROFILE_MED), 1)
surface = st.sidebar.selectbox("ChaussÃ©e", list(SURFACE_Î¼), 0)
tyre    = st.sidebar.radio("Pneus", ["neuf","use"], 0)
water   = st.sidebar.radio("Eau", ["aucune","pluie","flaques"], 0)
slope   = st.sidebar.selectbox("Pente", list(SLOPE), 0)
conf    = st.sidebar.slider("Confiance (%)", 0, 100, 95)/100
child_d = st.sidebar.slider("Distance de l'enfant (m)",5.,100.,25.,.5)
run_sim = st.sidebar.button("Lancer la simulation")

params = {
    "speed": speed,
    "profile": profile,
    "surface": surface,
    "tyre": tyre,
    "water": water,
    "slope": slope,
    "conf": conf,
}

tab_res, tab_var, tab_about = st.tabs(
    ["ðŸ“Š RÃ©sultats", "ðŸ” Variables", "â„¹ï¸ Ã€ propos"]
)

# --------------------------------------------------------------
# 5. ExÃ©cution / affichage
# --------------------------------------------------------------
if run_sim:
    t0 = time.time()
    progress = st.progress(0.0)
    dist = run_mc(params, progress_callback=progress.progress)
    progress.empty()
    dt  = time.time()-t0
    mean, p95 = dist.mean(), np.percentile(dist,95)
    p_coll = (dist >= child_d).mean()


    # -------- KPIs & histogramme --------------------------------------
    with tab_res:
        c1, c2, c3 = st.columns(3)
        c1.metric("Distance moyenne (m)", f"{mean:.1f}")
        c2.metric("Distance P95 (m)", f"{p95:.1f}")
        c3.metric("Collision", f"{p_coll*100:.1f} %")

        fig_hist = px.histogram(
            dist,
            nbins=60,
            labels={"value": "Distance d'arrÃªt (m)"},
        ).update_layout(title="Distribution simulÃ©e")
        st.plotly_chart(fig_hist, use_container_width=True)

        sorted_dist = np.sort(dist)
        cdf = np.arange(1, len(sorted_dist) + 1) / len(sorted_dist)
        fig_cdf = go.Figure(go.Scatter(x=sorted_dist, y=cdf))
        fig_cdf.update_layout(
            title="Fonction de rÃ©partition",
            xaxis_title="Distance d'arrÃªt (m)",
            yaxis_title="F(x)",
        )
        st.plotly_chart(fig_cdf, use_container_width=True)
        st.caption(f"{len(dist):,} tirages â€“ {dt:.2f}s")

    # -------- Distributions internes ----------------------------------
    with tab_var:
        st.subheader("Distributions internes")
        s1,s2,s3,s4 = st.tabs(
            ["Vitesse rÃ©elle","Temps rÃ©action","AdhÃ©rence Î¼","Pente Î¸"])
        # vitesse
        with s1:
            xs = np.linspace(speed_params(speed)[0], speed, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_speed(speed,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=speed_pdf(xs,speed))
            fig.update_layout(title="Vitesse rÃ©elle (km/h)")
            st.plotly_chart(fig,use_container_width=True)
        # tr
        with s2:
            xs = np.linspace(.3,3,300)
            fig = go.Figure()
            fig.add_histogram(x=sample_tr(profile,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=tr_pdf(xs,profile))
            fig.update_layout(title="Temps de rÃ©action (s)")
            st.plotly_chart(fig,use_container_width=True)
        # Î¼
        with s3:
            Î¼_min, Î¼_max = mu_bounds(base_mu(surface,tyre,water))
            xs = np.linspace(Î¼_min, Î¼_max, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_mu(surface,tyre,water,10_000),
                              nbinsx=40, histnorm="probability density",
                              opacity=.6)
            fig.add_scatter(x=xs,y=mu_pdf(xs,surface,tyre,water))
            fig.update_layout(title="Coefficient d'adhÃ©rence Î¼")
            st.plotly_chart(fig,use_container_width=True)
        # Î¸
        with s4:
            Î¼Î¸ = SLOPE[slope]
            xs = np.linspace(Î¼Î¸-1, Î¼Î¸+1, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_theta(slope,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=theta_pdf(xs,slope))
            fig.update_layout(title="Angle de pente Î¸ (Â°)")
            st.plotly_chart(fig,use_container_width=True)
else:
    tab_res.info("Aucun rÃ©sultat pour l'instant.")
    tab_var.markdown("_Les distributions apparaÃ®tront aprÃ¨s simulation._")

# ------------------ Ã€ propos ----------------------------------
with tab_about:
    mu_base = base_mu(surface, tyre, water)        # valeur nominale Î¼
    tr_nom  = PROFILE_MED[profile]                 # mÃ©diane temps rÃ©action

    st.markdown("### Vos paramÃ¨tres actuels")
    st.markdown(
        f"""
        â€¢ **Vitesse compteur :** {speed} km/h  
        â€¢ **Profil conducteur :** {profile}  â€“ temps de rÃ©action mÃ©dian â‰ˆ {tr_nom:.1f} s  
        â€¢ **ChaussÃ©e :** {surface}  
        â€¢ **Pneus :** {tyre}  
        â€¢ **Eau sur la route :** {water}  
        â€¢ **AdhÃ©rence nominale Î¼ :** {mu_base:.2f} (plage simulÃ©e Â±0,15)  
        â€¢ **Pente :** {SLOPE[slope]:+} Â° ({slope})  
        â€¢ **Confiance MC :** {conf*100:.0f} %  
        â€¢ **Distance enfant :** {child_d} m
        """
    )
