# app.py ‚Äî Simulateur de distance d‚Äôarr√™t
import streamlit as st
import numpy as np
import scipy.stats as stats
import math, time
import plotly.graph_objects as go
import plotly.express as px
from typing import Tuple

st.set_page_config(page_title="Simulateur ‚Äì Distance d‚Äôarr√™t",
                   page_icon="üöó", layout="wide")
st.title("Simulateur de distance d'arr√™t")
G = 9.81  # gravit√© (m¬∑s-2)

# ==============================================================
# 1. Lois de probabilit√©
# ==============================================================

# ---- Vitesse r√©elle (triangulaire, compteur sur-estimant) ----
def speed_params(v_disp: float) -> Tuple[float, float, float]:
    Œî = min(4 + 0.05 * v_disp, 8)           # tol√©rance UN-R39
    return v_disp - Œî, v_disp - Œî/2, v_disp

def sample_speed(v_disp: float, n: int) -> np.ndarray:
    a, c, b = speed_params(v_disp)
    return np.random.triangular(a, c, b, n)

def speed_pdf(x, v_disp):
    a, c, b = speed_params(v_disp)
    return np.where(
        (x >= a) & (x <= b),
        np.where(x < c,
                 2*(x-a)/((b-a)*(c-a)),
                 2*(b-x)/((b-a)*(b-c))),
        0)

# ---- Temps de r√©action (Weibull tronqu√©) ----
PROFILE_MED = {"alerte": .9, "standard": 1.5, "fatigue": 2.,
               "senior": 2., "worst": 2.5}
K_WEIB = 2.2

def weib_scale(med):               # Œª pour m√©diane donn√©e
    return med / (math.log(2)**(1/K_WEIB))

def sample_tr(profile, n):
    lam = weib_scale(PROFILE_MED[profile])
    return np.clip(stats.weibull_min.rvs(K_WEIB, scale=lam, size=n), .3, 3)

def tr_pdf(x, profile):
    lam = weib_scale(PROFILE_MED[profile])
    pdf = stats.weibull_min.pdf(x, K_WEIB, scale=lam)
    pdf[(x < .3) | (x > 3)] = 0
    return pdf

# ---- Adh√©rence Œº (B√™ta born√©e) ----
SURFACE_Œº = {
    "sec":     {"neuf": .85, "use": .75},
    "mouille": {"neuf": .55, "use": .40},
    "neige":   {"neuf": .25, "use": .25},
    "glace":   {"neuf": .10, "use": .10},
}
A_B, B_B = 2, 3

def base_mu(surface, tyre, water):
    Œº = SURFACE_Œº[surface][tyre]
    Œº -= .05 if water == "pluie"   else (.10 if water == "flaques" else 0)
    return np.clip(Œº, .2, .9)

def mu_bounds(Œº):
    return max(.2, Œº-.15), min(.9, Œº+.15)

def sample_mu(surface, tyre, water, n):
    Œº0 = base_mu(surface, tyre, water)
    Œº_min, Œº_max = mu_bounds(Œº0)
    return Œº_min + (Œº_max-Œº_min)*stats.beta.rvs(A_B, B_B, size=n)

def mu_pdf(x, surface, tyre, water):
    Œº0 = base_mu(surface, tyre, water)
    Œº_min, Œº_max = mu_bounds(Œº0)
    pdf = stats.beta.pdf((x-Œº_min)/(Œº_max-Œº_min), A_B, B_B)/(Œº_max-Œº_min)
    pdf[(x < Œº_min) | (x > Œº_max)] = 0
    return pdf

# ---- Pente Œ∏ (normale tronqu√©e ¬±1¬∞ autour du centre) ----
SLOPE = {"plat": 0, "rampe2": 2, "rampe4": 4, "rampe6": 6,
         "desc2": -2, "desc4": -4}

def sample_theta(cat, n):
    Œº = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    return stats.truncnorm.rvs(a, b, loc=Œº, scale=.5, size=n)

def theta_pdf(x, cat):
    Œº = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    pdf = stats.truncnorm.pdf(x, a, b, loc=Œº, scale=.5)
    pdf[(x < Œº-1) | (x > Œº+1)] = 0
    return pdf

# ==============================================================
# 2. Mod√®le physique (distance d‚Äôarr√™t)
# ==============================================================

def stopping_distance(v_kmh, t_r, Œº, Œ∏_deg):
    v_ms = v_kmh / 3.6                        # conversion km/h ‚Üí m/s
    Œ∏ = np.radians(Œ∏_deg)
    denom = 2*G*(Œº*np.cos(Œ∏) + np.sin(Œ∏))
    with np.errstate(divide="ignore", invalid="ignore"):
        dist = v_ms * t_r + (v_ms**2) / denom   # r√©action + freinage
    dist[denom <= 0] = np.inf
    return dist

# ==============================================================
# 3. Monte-Carlo adaptatif
# ==============================================================

def run_mc(p, batch=10_000, max_iter=4, progress_callback=None):
    z = stats.norm.ppf(.5 + p["conf"]/2)       # z-score dynamique
    rel_tol = 1 - p["conf"]                    # crit√®re largeur/ moyenne
    dist = np.empty(0)

    for i in range(max_iter):
        v = sample_speed(p["speed"], batch)
        t = sample_tr(p["profile"], batch)
        Œº = sample_mu(p["surface"], p["tyre"], p["water"], batch)
        Œ∏ = sample_theta(p["slope"], batch)

        ok = Œº*np.cos(np.radians(Œ∏)) + np.sin(np.radians(Œ∏)) > 0
        while not ok.all():                    # resampling invalid combos
            idx = np.where(~ok)[0]
            v[idx] = sample_speed(p["speed"], len(idx))
            t[idx] = sample_tr(p["profile"], len(idx))
            Œº[idx] = sample_mu(p["surface"], p["tyre"], p["water"], len(idx))
            Œ∏[idx] = sample_theta(p["slope"], len(idx))
            ok = Œº*np.cos(np.radians(Œ∏)) + np.sin(np.radians(Œ∏)) > 0

        dist = np.concatenate((dist, stopping_distance(v, t, Œº, Œ∏)))
        sem = np.std(dist, ddof=1)/np.sqrt(len(dist))
        if progress_callback:
            progress_callback((i+1)/max_iter)
        if z * sem / dist.mean() < rel_tol:
            break
    return dist

# ==============================================================
# 4. Interface Streamlit
# ==============================================================

st.sidebar.header("Param√®tres")

speed   = st.sidebar.slider("Vitesse compteur (km/h)", 30,130,90,5)
profile = st.sidebar.selectbox("Profil conducteur", list(PROFILE_MED), 1)
surface = st.sidebar.selectbox("Chauss√©e", list(SURFACE_Œº), 0)
tyre    = st.sidebar.radio("Pneus", ["neuf","use"], 0)
water   = st.sidebar.radio("Eau", ["aucune","pluie","flaques"], 0)
slope   = st.sidebar.selectbox("Pente (+ mont√©e)", list(SLOPE), 0)
conf    = st.sidebar.slider("Confiance (%)", 90,99,95)/100
child_d = st.sidebar.slider("Distance de l'enfant (m)",5.,100.,25.,.5)
run_sim = st.sidebar.button("Lancer la simulation")

params = {"speed":speed,"profile":profile,"surface":surface,"tyre":tyre,
          "water":water,"slope":slope,"conf":conf}

tab_sim, tab_res, tab_var, tab_about = st.tabs(
        ["üöó Simulation","üìä R√©sultats","üîç Variables","‚ÑπÔ∏è √Ä propos"])

# --------------------------------------------------------------
# 5. Ex√©cution / affichage
# --------------------------------------------------------------
if run_sim:
    t0 = time.time()
    progress = st.progress(0.0)
    dist = run_mc(params, progress_callback=progress.progress)
    progress.empty()
    dt  = time.time()-t0
    mean, p95 = dist.mean(), np.percentile(dist,95)
    p_coll = (dist >= child_d).mean()

    # -------- Animation ------------------------------------------------
    with tab_sim:
        frames, xmax = 30, max(child_d, p95)*1.2
        car_x = np.linspace(0,xmax,frames)
        frames_data = [go.Frame(data=[go.Scatter(x=[car_x[i]],y=[0],
                      mode="markers",marker=dict(size=18,color="blue")),
                      go.Scatter(x=[child_d],y=[0],mode="markers",
                      marker=dict(size=18,color="red"))],
                      name=str(i)) for i in range(frames)]
        layout = go.Layout(xaxis=dict(range=[-5,xmax],title="Position (m)"),
                           yaxis=dict(visible=False), showlegend=False,
                           updatemenus=[dict(type="buttons",
                             buttons=[dict(label="‚ñ∂Ô∏è Rejouer",method="animate",
                               args=[None,{"frame":{"duration":100,"redraw":True},
                                           "fromcurrent":True}])])])
        fig = go.Figure(data=frames_data[0].data, layout=layout,
                        frames=frames_data)
        st.plotly_chart(fig, use_container_width=True)
        st.markdown(f"**Probabilit√© de collision :** "
                    f"**{p_coll*100:.1f} %**  "
                    f"({len(dist):,} tirages ‚Äì {dt:.2f}s)")

    # -------- KPIs & histogramme --------------------------------------
    with tab_res:
        c1,c2,c3 = st.columns(3)
        c1.metric("Distance moyenne (m)", f"{mean:.1f}")
        c2.metric("Distance P95 (m)",     f"{p95:.1f}")
        c3.metric("Collision",            f"{p_coll*100:.1f} %")
        st.plotly_chart(px.histogram(dist, nbins=60,
                         labels={"value":"Distance d'arr√™t (m)"})
                         .update_layout(title="Distribution simul√©e"),
                         use_container_width=True)

    # -------- Distributions internes ----------------------------------
    with tab_var:
        st.subheader("Distributions internes")
        s1,s2,s3,s4 = st.tabs(
            ["Vitesse r√©elle","Temps r√©action","Adh√©rence Œº","Pente Œ∏"])
        # vitesse
        with s1:
            xs = np.linspace(speed_params(speed)[0], speed, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_speed(speed,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=speed_pdf(xs,speed))
            fig.update_layout(title="Vitesse r√©elle (km/h)")
            st.plotly_chart(fig,use_container_width=True)
        # tr
        with s2:
            xs = np.linspace(.3,3,300)
            fig = go.Figure()
            fig.add_histogram(x=sample_tr(profile,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=tr_pdf(xs,profile))
            fig.update_layout(title="Temps de r√©action (s)")
            st.plotly_chart(fig,use_container_width=True)
        # Œº
        with s3:
            Œº_min, Œº_max = mu_bounds(base_mu(surface,tyre,water))
            xs = np.linspace(Œº_min, Œº_max, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_mu(surface,tyre,water,10_000),
                              nbinsx=40, histnorm="probability density",
                              opacity=.6)
            fig.add_scatter(x=xs,y=mu_pdf(xs,surface,tyre,water))
            fig.update_layout(title="Coefficient d'adh√©rence Œº")
            st.plotly_chart(fig,use_container_width=True)
        # Œ∏
        with s4:
            ŒºŒ∏ = SLOPE[slope]
            xs = np.linspace(ŒºŒ∏-1, ŒºŒ∏+1, 300)
            fig = go.Figure()
            fig.add_histogram(x=sample_theta(slope,10_000), nbinsx=40,
                              histnorm="probability density", opacity=.6)
            fig.add_scatter(x=xs, y=theta_pdf(xs,slope))
            fig.update_layout(title="Angle de pente Œ∏ (¬∞)")
            st.plotly_chart(fig,use_container_width=True)
else:
    tab_sim.write("Cliquez sur **Lancer la simulation**.")
    tab_res.info("Aucun r√©sultat pour l'instant.")
    tab_var.markdown("_Les distributions appara√Ætront apr√®s simulation._")

# ------------------ √Ä propos ----------------------------------
with tab_about:
    mu_base = base_mu(surface, tyre, water)        # valeur nominale Œº
    tr_nom  = PROFILE_MED[profile]                 # m√©diane temps r√©action

    st.markdown("### Vos param√®tres actuels")
    st.markdown(
        f"""
        ‚Ä¢ **Vitesse compteur :** {speed} km/h  
        ‚Ä¢ **Profil conducteur :** {profile}  ‚Äì temps de r√©action m√©dian ‚âà {tr_nom:.1f} s  
        ‚Ä¢ **Chauss√©e :** {surface}  
        ‚Ä¢ **Pneus :** {tyre}  
        ‚Ä¢ **Eau sur la route :** {water}  
        ‚Ä¢ **Adh√©rence nominale Œº :** {mu_base:.2f} (plage simul√©e ¬±0,15)  
        ‚Ä¢ **Pente :** {SLOPE[slope]:+} ¬∞ ({slope})  
        ‚Ä¢ **Confiance MC :** {conf*100:.0f} %  
        ‚Ä¢ **Distance enfant :** {child_d} m
        """
    )
