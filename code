# app.py — Simulateur de distance d’arrêt
import streamlit as st
import numpy as np
import scipy.stats as stats
import math
import time
import plotly.graph_objects as go
import plotly.express as px
from typing import Tuple
import textwrap

st.set_page_config(page_title="Simulateur – Distance d’arrêt",
                   page_icon="🚗", layout="wide")
st.title("Simulateur de distance d'arrêt")
G = 9.81  # gravité (m·s-2)

# ==============================================================
# 1. Lois de probabilité
# ==============================================================

# ---- Vitesse réelle (triangulaire, compteur sur-estimant) ----
def speed_params(v_disp: float) -> Tuple[float, float, float]:
    Δ = min(4 + 0.05 * v_disp, 8)           # tolérance UN-R39
    return v_disp - Δ, v_disp - Δ/2, v_disp

def sample_speed(v_disp: float, n: int, rng=None) -> np.ndarray:
    rng = rng or np.random
    a, c, b = speed_params(v_disp)
    return rng.triangular(a, c, b, n)

def speed_pdf(x, v_disp):
    a, c, b = speed_params(v_disp)
    return np.where(
        (x >= a) & (x <= b),
        np.where(x < c,
                 2*(x-a)/((b-a)*(c-a)),
                 2*(b-x)/((b-a)*(b-c))),
        0)

# ---- Temps de réaction (Weibull tronqué) ----
PROFILE_MED = {
    "Alerte": 0.9,
    "Standard": 1.5,
    "Fatigué": 2.0,
    "Senior": 2.0,
}
K_WEIB = 2.2

def weib_scale(med):               # λ pour médiane donnée
    return med / (math.log(2)**(1/K_WEIB))

def sample_tr(profile, n, rng=None):
    lam = weib_scale(PROFILE_MED[profile])
    return np.clip(
        stats.weibull_min.rvs(K_WEIB, scale=lam, size=n, random_state=rng),
        0.3,
        3,
    )

def tr_pdf(x, profile):
    lam = weib_scale(PROFILE_MED[profile])
    pdf = stats.weibull_min.pdf(x, K_WEIB, scale=lam)
    pdf[(x < .3) | (x > 3)] = 0
    return pdf

# ---- Adhérence μ (Bêta bornée) ----
SURFACE_μ = {
    "sec":     {"neuf": .85, "mi-usure": .80, "usé": .75},
    "mouille": {"neuf": .55, "mi-usure": .47, "usé": .40},
    "neige":   {"neuf": .25, "mi-usure": .25, "usé": .25},
    "glace":   {"neuf": .10, "mi-usure": .10, "usé": .10},
}
A_B, B_B = 2, 3

def base_mu(surface, tyre):
    μ = SURFACE_μ[surface][tyre]
    return np.clip(μ, .2, .9)

def mu_bounds(μ):
    return max(.2, μ-.15), min(.9, μ+.15)

def sample_mu(surface, tyre, n, rng=None):
    μ0 = base_mu(surface, tyre)
    μ_min, μ_max = mu_bounds(μ0)
    rng = rng or np.random
    return μ_min + (μ_max - μ_min) * rng.beta(A_B, B_B, size=n)

def mu_pdf(x, surface, tyre):
    μ0 = base_mu(surface, tyre)
    μ_min, μ_max = mu_bounds(μ0)
    pdf = stats.beta.pdf((x-μ_min)/(μ_max-μ_min), A_B, B_B)/(μ_max-μ_min)
    pdf[(x < μ_min) | (x > μ_max)] = 0
    return pdf

# ---- Pente θ (normale tronquée ±1° autour du centre) ----
SLOPE = {
    "Plat": 0,
    "Montée 2°": 2,
    "Montée 4°": 4,
    "Descente 2°": -2,
    "Descente 4°": -4,
}

def sample_theta(cat, n, rng=None):
    μ = SLOPE[cat]
    a, b = (-1) / 0.5, 1 / 0.5
    return stats.truncnorm.rvs(a, b, loc=μ, scale=0.5, size=n, random_state=rng)

def theta_pdf(x, cat):
    μ = SLOPE[cat]; a, b = (-1)/.5, (1)/.5
    pdf = stats.truncnorm.pdf(x, a, b, loc=μ, scale=.5)
    pdf[(x < μ-1) | (x > μ+1)] = 0
    return pdf

# ==============================================================
# 2. Modèle physique (distance d’arrêt)
# ==============================================================

def stopping_distance(v_kmh, t_r, μ, θ_deg):
    v_ms = v_kmh / 3.6                        # conversion km/h → m/s
    θ = np.radians(θ_deg)
    denom = 2*G*(μ*np.cos(θ) + np.sin(θ))
    with np.errstate(divide="ignore", invalid="ignore"):
        dist = v_ms * t_r + (v_ms**2) / denom   # réaction + freinage
    dist[denom <= 0] = np.inf
    return dist

# ==============================================================
# 3. Monte-Carlo adaptatif
# ==============================================================

def run_mc(p, batch=50_000, max_iter=20, progress_callback=None):
    z = stats.norm.ppf(.5 + p["conf"]/2)       # z-score dynamique
    rel_tol = 1 - p["conf"]                    # critère largeur/ moyenne
    dist = np.empty(0)

    for i in range(max_iter):
        v = sample_speed(p["speed"], batch)
        t = sample_tr(p["profile"], batch)
        μ = sample_mu(p["surface"], p["tyre"], batch)
        θ = sample_theta(p["slope"], batch)

        ok = μ*np.cos(np.radians(θ)) + np.sin(np.radians(θ)) > 0
        while not ok.all():                    # resampling invalid combos
            idx = np.where(~ok)[0]
            v[idx] = sample_speed(p["speed"], len(idx))
            t[idx] = sample_tr(p["profile"], len(idx))
            μ[idx] = sample_mu(p["surface"], p["tyre"], len(idx))
            θ[idx] = sample_theta(p["slope"], len(idx))
            ok = μ*np.cos(np.radians(θ)) + np.sin(np.radians(θ)) > 0

        assert ok.all(), "Invalid combinaison donnant denom <= 0"

        dist = np.concatenate((dist, stopping_distance(v, t, μ, θ)))
        sem = np.std(dist, ddof=1)/np.sqrt(len(dist))
        if progress_callback:
            progress_callback(int((i + 1) / max_iter * 100))
        if z * sem / dist.mean() < rel_tol:
            break
    return dist

# ==============================================================
# 4. Interface Streamlit
# ==============================================================

st.sidebar.header("Paramètres")
advanced = st.sidebar.toggle("Mode avancé")

if advanced:
    speed   = st.sidebar.slider("Vitesse compteur (km/h)", 30,130,90,5)
    profile = st.sidebar.radio("Profil conducteur", list(PROFILE_MED), 1)
    surface = st.sidebar.radio("Chaussée", list(SURFACE_μ), 0)
    tyre    = st.sidebar.radio("Pneus", list(SURFACE_μ["sec"].keys()), 0)
    slope   = st.sidebar.radio("Pente", list(SLOPE), 0)
    conf    = st.sidebar.slider("Confiance (%)", 0, 100, 95)/100
else:
    PRESETS = {
        "Ville (sec)":      {"speed": 30,  "profile": "Standard", "surface": "sec",     "tyre": "neuf",     "slope": "Plat"},
        "Route mouillée":   {"speed": 80,  "profile": "Fatigué",  "surface": "mouillé", "tyre": "mi-usure", "slope": "Plat"},
        "Autoroute (sec)":  {"speed": 130, "profile": "Alerte",   "surface": "sec",     "tyre": "neuf",     "slope": "Plat"},
    }
    preset_name = st.sidebar.radio("Préréglage", list(PRESETS))
    pr = PRESETS[preset_name]
    speed, profile, surface, tyre, slope = pr.values()
    conf = 0.95

child_d = st.sidebar.slider("Distance de l'enfant (m)",5.,100.,25.,.5)
run_sim = st.sidebar.button("Lancer la simulation")

params = {
    "speed": speed,
    "profile": profile,
    "surface": surface,
    "tyre": tyre,
    "slope": slope,
    "conf": conf,
}

tab_res, tab_graph, tab_var, tab_about = st.tabs([
    "📊 Résultats",
    "📈 Graphiques",
    "🔎 Variables",
    "ℹ️ À propos",
])

# --------------------------------------------------------------
# 5. Exécution / affichage
# --------------------------------------------------------------
if "dist" not in st.session_state:
    st.session_state["dist"] = None
    st.session_state["params"] = None

if run_sim:
    t0 = time.time()
    progress = st.progress(0)
    with st.spinner("Simulation en cours..."):
        dist = run_mc(params, progress_callback=progress.progress)
    progress.empty()
    dt = time.time() - t0
    st.session_state["dist"] = dist
    st.session_state["params"] = params
elif (
    st.session_state["dist"] is not None
    and st.session_state["params"] == params
):
    dist = st.session_state["dist"]
    dt = 0
else:
    dist = None
if dist is not None:
    mean, p95 = dist.mean(), np.percentile(dist, 95)
    p_coll = (dist >= child_d).mean()

    # -------- KPIs --------------------------------------
    with tab_res:
        c1, c2, c3 = st.columns(3)
        c1.metric("Distance moyenne (m)", f"{mean:.1f}")
        c2.metric("Distance P95 (m)", f"{p95:.1f}")
        c3.metric("Collision", f"{p_coll*100:.1f} %")

    # -------- Graphiques --------------------------------------
    with tab_graph:
        fig_hist = (
            px.histogram(dist, nbins=60, labels={"value": "Distance d'arrêt (m)"})
            .update_layout(title="Distribution simulée")
        )
        st.plotly_chart(fig_hist, use_container_width=True)

        sorted_dist = np.sort(dist)
        cdf = np.arange(1, len(sorted_dist) + 1) / len(sorted_dist)
        fig_cdf = go.Figure(go.Scatter(x=sorted_dist, y=cdf, name="CDF"))
        fig_cdf.add_vline(
            x=child_d,
            line_dash="dash",
            line_width=2,
            annotation_text="Position de l’enfant",
            annotation_position="top",
        )
        fig_cdf.update_layout(
            title="Probabilité de s'arrêter",
            xaxis_title="Distance d'arrêt (m)",
            yaxis_title="Probabilité",
        )
        st.plotly_chart(fig_cdf, use_container_width=True)

        rng_scatter = np.random.default_rng(42)
        v_s = sample_speed(speed, 1000, rng_scatter)
        t_s = sample_tr(profile, 1000, rng_scatter)
        μ_s = sample_mu(surface, tyre, 1000, rng_scatter)
        fig_scatter = px.scatter(
            x=t_s,
            y=v_s,
            color=μ_s,
            color_continuous_scale="Blues",
            labels={"x": "Temps de réaction (s)", "y": "Vitesse (km/h)", "color": "Adhérence"},
            title="Temps de réaction vs Vitesse",
        )
        st.plotly_chart(fig_scatter, use_container_width=True)
        st.caption(
            f"{format(len(dist), ',').replace(',', '\u202f')} tirages – {dt:.2f}s"
        )

    # -------- Distributions internes ----------------------------------
    with tab_var:
        st.subheader("Distributions internes")
        rng = np.random.default_rng(42)

        with st.expander("Vitesse réelle"):
            xs = np.linspace(speed_params(speed)[0], speed, 300)
            fig = go.Figure()
            data = sample_speed(speed, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=speed_pdf(xs, speed))
            fig.update_layout(title="Vitesse réelle (km/h)")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Temps de réaction"):
            xs = np.linspace(0.3, 3, 300)
            fig = go.Figure()
            data = sample_tr(profile, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=tr_pdf(xs, profile))
            fig.update_layout(title="Temps de réaction (s)")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Adhérence μ"):
            μ_min, μ_max = mu_bounds(base_mu(surface, tyre))
            xs = np.linspace(μ_min, μ_max, 300)
            fig = go.Figure()
            data = sample_mu(surface, tyre, 10_000, rng)
            fig.add_histogram(
                x=data,
                nbinsx=40,
                histnorm="probability density",
                opacity=0.6,
            )
            fig.add_scatter(x=xs, y=mu_pdf(xs, surface, tyre))
            fig.update_layout(title="Coefficient d'adhérence μ")
            st.plotly_chart(fig, use_container_width=True)

        with st.expander("Pente θ"):
            μθ = SLOPE[slope]
            xs = np.linspace(μθ - 1, μθ + 1, 300)
            fig = go.Figure()
            data = sample_theta(slope, 10_000, rng)
            fig.add_histogram(
                x=data, nbinsx=40, histnorm="probability density", opacity=0.6
            )
            fig.add_scatter(x=xs, y=theta_pdf(xs, slope))
            fig.update_layout(title="Angle de pente θ (°)")
            st.plotly_chart(fig, use_container_width=True)
else:
    tab_res.info("Aucun résultat pour l'instant.")
    tab_var.markdown("_Les distributions apparaîtront après simulation._")

# ------------------ À propos ----------------------------------
with tab_about:
    mu_base = base_mu(surface, tyre)        # valeur nominale μ
    tr_nom  = PROFILE_MED[profile]                 # médiane temps réaction

    st.markdown("### Vos paramètres actuels")
    st.markdown(
        textwrap.dedent(
            f"""
            • **Vitesse compteur :** {speed} km/h
            • **Profil conducteur :** {profile}  – temps de réaction médian ≈ {tr_nom:.1f} s
            • **Chaussée :** {surface}
            • **Pneus :** {tyre}
            • **Adhérence nominale μ :** {mu_base:.2f} (plage simulée ±0,15)
            • **Pente :** {SLOPE[slope]:+} ° ({slope})
            • **Confiance MC :** {conf*100:.0f} %
            • **Distance enfant :** {child_d} m
            """
        )
    )
